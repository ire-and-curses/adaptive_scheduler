# Notes from Gurobi kernel optimization story in May 2016
# jnation

Gurobi kernel optimization was attempted using the autotune tool to try to auto-select good parameters for a set of models.
While this worked well at finding parameters for a single model, it failed to find any useful parameters for a set of four models.
Some of the most promising parameters found through single model experimentation were as follows:
    MIPFocus = 1 [default 0] - change preference to find feasible solutions quickly, at the expense of finding the best solution
    Method = 2 [-1] - use the barrier method to solve the linear problem
    VarBranch = 1 [-1] - use Psuedo Shadow Price Branching method of selecting branches
    GomoryPasses = 15 [-1] - Max # of Gomory cut passes
    Heuristics = 0.5 [0.05] - % of time spent on trying heuristic solutions rather following branches
    Presolve = 2 [-1] - aggressive presolve phase, more time spent but model is pruned more

Warm start solutions for the MIP portion of the problem were implemented in the scheduler during this time.
This is done by feeding in the previous decision of is_scheduled for a block starting at a specific time on a specific resource.
This seemed to have an improvement on the runtime, but the kernel was still prone to taking its maximum amount of time
if the problem had changed a lot and was sufficiently hard.

Callbacks can be used by the Gurobi kernel to call any piece of code you want periodically while computing its solution,
allowing you to terminate the run at any time or guide the solution process. We experimented with some callbacks to try
something like terminating the optimization if the gap between the best solution and the objective bound had not changed
in X seconds. Other ideas were to use the callback to put a constraint on either time or the gap, meaning if X seconds
had passed and we had reached the threshold, then terminate, otherwise go until we reach the threshold or timeout. An
example callback for terminating if we get stuck is below:


def gurobi_cb(model, where):
    # These 3 'where' variable values are the possible stages of the MIP optimization process
    if where == gurobipy.GRB.callback.MIP:
        obj_best = model.cbGet(gurobipy.GRB.callback.MIP_OBJBST)
        elapsed = model.cbGet(gurobipy.GRB.callback.RUNTIME)
        obj_bound = model.cbGet(gurobipy.GRB.callback.MIP_OBJBND)
        gap = (abs(obj_bound) - abs(obj_best)) / abs(obj_bound)
    elif where == gurobipy.GRB.callback.MIPSOL:
        obj = model.cbGet(gurobipy.GRB.callback.MIPSOL_OBJ)
        obj_best = model.cbGet(gurobipy.GRB.callback.MIPSOL_OBJBST)
        elapsed = model.cbGet(gurobipy.GRB.callback.RUNTIME)
        obj_bound = model.cbGet(gurobipy.GRB.callback.MIPSOL_OBJBND)
        gap = (abs(obj_bound) - abs(obj)) / abs(obj_bound)
    elif where == gurobipy.GRB.callback.MIPNODE:
        obj_best = model.cbGet(gurobipy.GRB.callback.MIPNODE_OBJBST)
        elapsed = model.cbGet(gurobipy.GRB.callback.RUNTIME)
        obj_bound = model.cbGet(gurobipy.GRB.callback.MIPNODE_OBJBND)
        gap = (abs(obj_bound) - abs(obj_best)) / abs(obj_bound)
    else:
        return
    if abs(model._gap_last_change - gap) > 0.0001:
        # if we have had a change greater than .01% in the last 100 seconds, record the new gap and reset the timer
        model._gap_last_change = gap
        model._since_last_change = elapsed
        print("setting gap_last_change to {}, time since last change: {}".format(model._gap_last_change, model._since_last_change))
    elif (elapsed - model._since_last_change) > 100:
        # if its been more than 100 seconds without a .01% change in the gap, then terminate
        print ("terminating solve due to lack of progress")
        model.terminate()
    else:
        print("gap = {}".format(gap))

You must also set the following user parameters on the model to store/modify between runs in the callback:

    # user variables for the callback function to check/modify
    m._gap_last_change = 0
    m._since_last_change = 0

Here is a sample callback function for converting the messages printed to std_out to log messages in the scheduler:

def gurobi_cb(model, where):
    if where == GRB.Callback.MESSAGE:
        log.info(model.cbGet(GRB.Callback.MSG_STRING))

You must also set the following parameter on the model to keep it from printing its messages:

    m.params.OutputFlag = 0
